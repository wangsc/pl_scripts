#!/usr/bin/perl -w
use strict;
use Bio::DB::Fasta;
use Bio::SearchIO;

my $sUsage = <<END;
Usage:
perl $0
<ortholog gene pairs list file, 3B_S293	3A_S1531>
<3B contig/BAC sequences in fasta>
<3B annotation file generated by PASA, gff3 format>
<3A contig/scafold sequence in fasta>
<3A annotation file generated by PASA, gff3 format>
<output file>
END

die $sUsage unless @ARGV >= 5;

my ($ortho_file, $B_ctg_file, $B_gff, $A_ctg_file, $A_gff, $outfile) = @ARGV;
open (OUT, ">$outfile") or die;

my @ortho_A_B = read_ortho_file($ortho_file);
my $gn_3A = Bio::DB::Fasta->new($A_ctg_file);
my $gn_3B = Bio::DB::Fasta->new($B_ctg_file);

my ($B_genomic_pos, $B_gene_struc, $B_gene_ctg, $B_isoform_struc) = read_gff($B_gff);
my ($A_genomic_pos, $A_gene_struc, $A_gene_ctg, $A_isoform_struc) = read_gff($A_gff);

foreach (@ortho_A_B)
{
	chomp;
	my @out=split /\s+/,$_;
	my $out_file = join("-", @out) . ".fasta";

	my ($b_gene, $a_gene) = $_=~/3B_(\S+)\s+3A_(\S+)/;
	my $b_gene_seq = get_seq($gn_3B, $b_gene, $B_genomic_pos, $B_gene_struc, $B_gene_ctg);
	my $a_gene_seq = get_seq($gn_3A, $a_gene, $A_genomic_pos, $A_gene_struc, $A_gene_ctg);
	
	&run_blast2seq($b_gene_seq, $a_gene_seq, @out);
	# exit if $b_gene eq 'S223';
	my ($b_aln_start, $b_aln_end, $b_strand, $a_aln_start, $a_aln_end, $a_strand) = parse_blast2seq();
	print STDERR join(" ", ($b_aln_start, $b_aln_end, $b_strand, $a_aln_start, $a_aln_end, $a_strand) ), "\n";
	my @b_iso_struc_trans = transform_coordinate($B_isoform_struc->{$b_gene}, $b_aln_start, $b_aln_end, $b_strand, $b_gene);
	
	if($b_gene eq 'S223')
	{
		print STDERR "\nS223\t", $b_aln_start, "\t", $b_aln_end, "\t", $b_strand, "\n";
		foreach (@b_iso_struc_trans)
		{
			my @arr;
			foreach (@$_)
			{
				push @arr, join("-", @$_);
			}
			print STDERR join("\t", @arr), "\n"
		}
		exit
	}
	
	my @a_iso_struc_trans = transform_coordinate($A_isoform_struc->{$a_gene}, $a_aln_start, $a_aln_end, $a_strand, $a_gene);
	
	print OUT "3B", $b_gene, "\t", "3A", $a_gene, "\t ", scalar @b_iso_struc_trans, "\t", scalar @a_iso_struc_trans, "\n";
	next if @b_iso_struc_trans == 1 and @a_iso_struc_trans == 1;
	
	my %b_AS_events = compare_isoforms($b_aln_end - $b_aln_start+1, @b_iso_struc_trans);
	my %a_AS_events = compare_isoforms($a_aln_end - $a_aln_start+1, @a_iso_struc_trans);
	
	my @as_events = qw(ADE AAE CE RI SI SE RE);
	
	print OUT "\t"x5, "3B_", $b_gene, "-3A_",$a_gene;
	foreach my $as (@as_events)
	{
		my @exons_overlap;
		my @b_exons;
		my @a_exons;
		if(exists $b_AS_events{$as})
		{
			@b_exons = @{$b_AS_events{$as}};
			#$b_exons = scalar @{$b_AS_events{$as}};
		}

		if(exists $a_AS_events{$as})
		{
			@a_exons =  @{$a_AS_events{$as}};
			#$a_exons = scalar @{$a_AS_events{$as}};
		}		
		
		@exons_overlap = check_overlapping(\@b_exons, \@a_exons);
		
		#my $diff = (scalar @exons) - $a_exons + (scalar @exons) - $b_exons;
		my $diff = (scalar @b_exons) + (scalar @a_exons) - 2* (scalar @exons_overlap); 
		$diff = 0 if $diff <0;
		print OUT "\t", join("\t", (scalar @b_exons, scalar @a_exons, $diff));
	}
	print OUT "\n";
}



# Subroutines
sub check_overlapping
{
	my @arrref = @_;
	@arrref = reverse @arrref if (@{$arrref[0]} > @{$arrref[1]});
	my ($b_ref, $a_ref) = @arrref;
	
	my @return;
	
	foreach (@$b_ref)
	{
		my ($start, $end) = split /_/, $_;
		my $overlap = 0;
		foreach (@$a_ref)
		{
			my @pos = split /_/, $_;
			if( ($pos[0]>=$start and $pos[0] <= $end) or ($start >= $pos[0] and $start <= $pos[1]) )
			{
				$overlap = 1;
				last;
			}
		}
		push @return, $_ if $overlap;
	}
	
	return @return;
}


sub compare_isoforms
{
	my ($seq_len, @iso_struc) = @_;
	my %return;
	foreach my $m (0..$#iso_struc)
	{
		my ($b_vec) = construct_vec($iso_struc[$m], $seq_len);
		foreach my $j (0..$#iso_struc)
		{
			next if $j == $m;
			my ($a_vec) = construct_vec($iso_struc[$j], $seq_len);
			my @coding_segments = calculate_coding_segment($b_vec, $a_vec, $seq_len);
						
			my ($ade, $aae, $ri, $si, $se, $re, $ce) = (0,0,0,0,0,0,0);
			foreach  my $index (0..$#coding_segments)
			{
				my $segment = $coding_segments[$index];
				my $status = $segment->[2];
				next if $status == 0;
				if ($status == 11)
				{
					if ($coding_segments[$index-1]->[2] == 0 and $coding_segments[$index+1]->[2] == 0) # ce
					{
						$ce++;
						push @{$return{'CE'}}, join("_", ($coding_segments[$index]->[0],  $coding_segments[$index]->[1]));
					}
					next;
				}
				if ($coding_segments[$index-1]->[2] == 11 and $coding_segments[$index+1]->[2] == 0) # ade
				{
					$ade++ ;
					push @{$return{'ADE'}}, join("_", ($coding_segments[$index]->[0],  $coding_segments[$index]->[1]));
				}
				if($coding_segments[$index-1]->[2] == 00 and $coding_segments[$index+1]->[2] == 11) # aae
				{
					$aae++;
					push @{$return{'AAE'}}, join("_", ($coding_segments[$index]->[0],  $coding_segments[$index]->[1]));
				}
				if ($coding_segments[$index-1]->[2] == 11 and $coding_segments[$index+1]->[2] == 11 and $status == 10) #ru
				{
					$ri++;
					push @{$return{'RI'}}, join("_", ($coding_segments[$index]->[0],  $coding_segments[$index]->[1]));;
				}
				if ($coding_segments[$index-1]->[2] == 11 and $coding_segments[$index+1]->[2] == 11 and $status == 1) #si
				{
					$si++;
					push @{$return{'SI'}}, join("_", ($coding_segments[$index]->[0],  $coding_segments[$index]->[1]));
				}
				if ($coding_segments[$index-1]->[2] == 0 and $coding_segments[$index+1]->[2] == 0 and $status == 1) #se
				{
					$se++;
					push @{$return{'SE'}}, join("_",($coding_segments[$index]->[0],  $coding_segments[$index]->[1]));
				}
				if ($coding_segments[$index-1]->[2] == 0 and $coding_segments[$index+1]->[2] == 0 and $status == 10) #re
				{
					$re++;
					push @{$return{'RE'}}, join("_", ($coding_segments[$index]->[0],  $coding_segments[$index]->[1]));
				}
			}
		}
	}
	#map{ $return{$_}  = [rm_redundant($return{$_})] } keys %return;
	#print STDERR join("\t", keys %return), "\n";
	foreach my $event (keys %return)
	{
		print STDERR 'Event: ', $event, "\n";
		my $arrayref = $return{$event};
		unless (ref($arrayref) eq 'ARRAY')
		{
			print STDERR $_, "!\t", $arrayref, "!\n";
			die;
		}
		#print STDERR $arrayref, "\n";
		my @unique_regions = unique(@$arrayref);
		print STDERR join("*\t", @unique_regions), "*\n";
		$return{$event} = [@unique_regions];
	}
	
	return %return;
}


sub transform_coordinate
{
	my ($arrayref, $start, $end, $strand, $gene) = @_;
	($start , $end) = ($end, $start) if $start > $end;
	print STDERR "S223 start_end\t", $start, "\t$end\n" if $gene eq 'S223';
	my @return;
	foreach (@$arrayref)
	{
		my @exons = @$_;
		my @transformed;
		
		foreach (@exons)
		{
			my ($s, $e) = @$_;
			print STDERR "S223\t", $s, " * ", $e, "\n" if $gene eq 'S223'; 
			next if $e <= $start;
			next if $s >= $end;
			print STDERR "** S223\t", $s, "\t", $e, "\n" if $gene eq 'S223'; 
			push @transformed, [($s-$start+1)<=0?1:$s-$start+1, $end-$start+1];
		}
		
		push @return, [@transformed]
	}
	
	if($strand == -1)
	{
		foreach my $index (0..$#return)
		{
			#print STDERR scalar @{$return[$index]}, "\n";
			my $n = 0;
			foreach ( 0 .. scalar @{$return[$index]} -1 )
			{
				$n++;
				#print STDERR "N: ", $n, "\n";
				my ($s, $e) = @{$return[$index][$_]};
				#print STDERR join("**", ($s, $e)), "\n";
			  $return[$index][$_] = [$end-$start+2-$e, $end-$start+2-$s];
			}
			
		}
		@return = reverse @return;
	}
	
	foreach (0..$#return)
	{
		my @pos = @{$return[$_]};
		foreach (0..$#pos)
		{
			my ($s, $e) = @{$pos[$_]};
			$pos[$_] = [$s+3, $e+3];
		}
		$return[$_] = [@pos];
	}
	
	return @return;
}



sub parse_blast2seq
{
	my $searchio = Bio::SearchIO->new(-format => 'blast', -file => "blastn2seq.out", -report_type => 'blastn');
	while (my $result = $searchio->next_result())
	{
		#last unless defined $result;
		my $hit = $result->next_hit;
		#last unless defined $hit;
		while (my $hsp = $hit->next_hsp)
		{
			my $query_string = $hsp->query_string;
			my $query_start = $hsp->start('query');
			my $query_end = $hsp->end('query');
			my $query_strand = $hsp->strand('query');
			#my $query_string_formatted = format_sequence($query_string, $query_start, $B_gene_struc->{$b_gene});
			
			my $hit_string = $hsp->hit_string;
			my $hit_start = $hsp->start('hit');
			my $hit_end = $hsp->end('hit');
			my $hit_strand = $hsp->strand('hit');
			#my $hit_string_formatted = format_sequence($hit_string, $hit_start, $A_gene_struc->{$a_gene});
			return($query_start, $query_end, $query_strand, $hit_start, $hit_end, $hit_strand);	
			last;
		}		
	}	
}



sub run_blast2seq
{
	my ($b_gene_seq, $a_gene_seq, @out) = @_;
	open (Q, ">query") or die;
	print Q ">$out[0]\n", $b_gene_seq, "\n";
	close Q;
	
	open (S, ">subject") or die;
	print S ">$out[1]\n", $a_gene_seq, "\n";
	close S;
	
	my $blast_cmd = "bl2seq -i query -j subject -p blastn -o blastn2seq.out";
	system($blast_cmd);
	#print STDERR "Finish bl2seq ...\n";	
}


sub compare_structure
{
	my ($seqa, $seqb) = @_;
	print STDERR length  $seqa, " *** ", length  $seqb, "\n";
	my @struc_a = get_structure($seqa);
	my @struc_b = get_structure($seqb);
	my @count_seg = count_coding_segments(\@struc_a, \@struc_b, length $seqa);
	return @count_seg;
}

sub get_structure
{
	my $seq = shift; 
	my @return;
	my @bases = split //, $seq;
	print STDERR 'length of seq: ', length $seq, "\t", 'length of array: ', scalar @bases, "\n";
	my $start;
	my $end;
	foreach my $index (0..$#bases)
	{
		if($index == $#bases and defined $start)
		{
			if($bases[$index] eq '-')
			{
				$end = $index;
				while($bases[$end] eq '-')
				{
					$end--;
				}
				push @return, [$start, $end];
			}
			next
		}
		
		if($bases[$index] =~ /[ATGCN]/)
		{
			$start = $index unless defined $start;
			if ($index == $#bases){push @return, [$start, $end]}
		}
		elsif($bases[$index] =~ /[atgcn]/)
		{
			if(defined $start)
			{
				$end = $index - 1;
				while($bases[$end] eq '-')
				{
					$end--;
				}
				push @return, [$start, $end];
				print STDERR join(",", ($start, $end)), "\n";
				undef($start);
			}
		}
	}
	return @return;
}

sub format_sequence
{
	my ($seq, $start, $structures) = @_;
	my %exon_pos;
	foreach (@$structures)
	{
		my ($start, $end) = split /_/, $_;
		map{ $exon_pos{$_}=1 } $start .. $end;
	}
	$seq =~ s/\s+$//;
	$seq = lc($seq);
	my $pos = $start - 1; 
	foreach my $index (0 .. (length $seq)-1)
	{
	 	my $base = substr $seq, $index, 1;
	 	next if $base eq '-';
	 	$pos++;
	 	substr ($seq, $index, 1) = uc($base) if exists $exon_pos{$pos};
	}
	
	return 'aaaaa' . $seq . 'aaaaa';	
}




sub get_seq
{
	my ($gn, $gene, $genomic_pos, $gene_struc, $gene_ctg) = @_;
	my $seq = $gn->seq($gene_ctg->{$gene}, $genomic_pos->{$gene}[0] => $genomic_pos->{$gene}[1]);
	$seq = lc ($seq);
	foreach (@{$gene_struc->{$gene}})
	{
		my ($start, $end) = split /_/, $_;
		my $subseq = substr ($seq, $start-1, ($end-$start+1));
		substr ($seq, $start-1, ($end-$start+1)) = uc($subseq);
	}
	return $seq;
}


sub read_ortho_file
{
	my $file = shift;
	open (IN, $file) or die;
	
	my @return;
	while (<IN>)
	{
		# 3B_S293	3A_S1531
		# 3B_S206	3A_S2560
		# 3B_S356	3A_S5665		
		chomp; next if /^\s+$/;

		push @return, $_;
	}
	close IN;
	return @return;
}


sub read_gff
{
	my $file = shift;
	open (IN, $file) or die "Error opening file $file\n";
	my (%genomic_pos, %gene_structure, %gene_ctg);
	my %recorder;
	my %asmbl_to_gene;
	my %asmbl_struc;
	my %gene_strand;
	while(<IN>)
	{
		chomp; 
		next unless /\S/;
		# gi|300681572|emb|FN645450.1|	PASA	cDNA_match	16861	17032	.	+	.	ID=S319-asmbl_397; Target=asmbl_397 1 172 +
		# gi|300681572|emb|FN645450.1|	PASA	cDNA_match	17453	17519	.	+	.	ID=S319-asmbl_397; Target=asmbl_397 173 239 +
		# gi|300681572|emb|FN645450.1|	PASA	cDNA_match	17597	17670	.	+	.	ID=S319-asmbl_397; Target=asmbl_397 240 313 +
		my $gene_id = $1 if /ID=(\S+?)\-/;
		my $asmbl_id = $1 if /(asmbl_\d+)/;
		$asmbl_to_gene{$asmbl_id} = $gene_id;
		my @t = split /\s+/, $_;
		push @{$asmbl_struc{$asmbl_id}}, [@t[3,4]];		
		$gene_strand{$gene_id} = $t[6] unless defined $gene_strand{$gene_id};
		$gene_ctg{$gene_id} = $t[0];
		push @{$recorder{$gene_id}}, join("_", @t[3, 4]); 
	}
	close IN;
	
	foreach my $id (keys %recorder)
	{
		my ($start, $end);
		my @exons = @{$recorder{$id}};
		my @tmp;
		foreach (@exons){push @tmp, (split/_/,$_)}
		@tmp = sort {$a<=>$b} @tmp;
		($start, $end) = @tmp[0, -1];
		$genomic_pos{$id} = $gene_strand{$id} eq '+'? [$start, $end] : [$end, $start];
		
		my @new_exons;
		foreach (@exons)
		{
			my @t = split /_/,$_; 
			@t=map{$_-$start+1}@t;
			push @new_exons, join('_', sort{$a<=>$b}@t);
		}
		$gene_structure{$id} = [unique(@new_exons)]
	}
	
	my %isoform_struc;
	foreach my $asmbl (keys %asmbl_struc)
	{
		my $gene = $asmbl_to_gene{$asmbl};
		my @exons = @{$recorder{$gene}};
		my @tmp;
		foreach (@exons){push @tmp, (split/_/,$_)}
		@tmp = sort {$a<=>$b} @tmp;
		my $start = $tmp[0];
		print STDERR 'S223 gene start: ', $start, "\n" if $gene eq 'S223';
		my @new_exons;
		
		foreach my $index (0.. scalar @{$asmbl_struc{$asmbl}}-1)
		{
			my ($s, $e) = @{$asmbl_struc{$asmbl}[$index]};
			print STDERR join("\t", ($s, $e,$s-$start+1, $e-$start+1)), "\n" if $gene eq 'S223';
			push @new_exons, [$s-$start+1, $e-$start+1];
			#unless (@new_exons){push @new_exons, [$s-$start+1, $e-$start+1]; next}
			#push @new_exons, [$new_exons[$index-1][1]+1, $new_exons[$index-1][1]+1+$e-$s]
		}
		
		push @{$isoform_struc{$gene}}, [@new_exons];
	}
	
	return(\%genomic_pos, \%gene_structure, \%gene_ctg, \%isoform_struc)
}

sub calc_asmbl_exon_pos
{
	my $arrayref = shift;
	my $min;
	foreach (@$arrayref)
	{
		my ($s, $e) = @$_;
		$min = $s unless defined $min;
		$min  = $s if $s < $min;
	}
	
	my @return;
	foreach (@$arrayref)
	{
		my ($s, $e) = @$_;
		push @return, [$s-$min, $e-$min];
	}
	
	@return = sort {$a->[0] <=> $b->[0]} @return;
	
	return @return;
}


sub unique
{
	my %hash = map {$_, 1} @_;
	return keys %hash;
}

sub count_coding_segments
{
	my ($wise_ref, $pasa_ref, $seq_len) = @_;
	my @return_array;
	my $num_exons = 0;
	my $num_compare = 0;
	my ($ade, $aae, $ri, $si, $se, $re, $ce) = (0,0,0,0,0,0,0);
	my ($alt_acc_exon, $alt_donor_exon) = (0, 0);
	my ($wise_vec) = construct_vec($wise_ref);
	my ($pasa_vec) = construct_vec($pasa_ref);
#	my $coverage = calculate_coverage($wise_vec, $pasa_vec, $wise_max);
	my @coding_segments = calculate_coding_segment($wise_vec, $pasa_vec, $seq_len);
	my $total_segs = scalar @coding_segments;
	my $alternative_segs = 0;
	foreach  my $index (0..$#coding_segments)
	{
		my $segment = $coding_segments[$index];
		my $status = $segment->[2];
		next if $status == 0;
		if ($status == 11){$ce++ if $coding_segments[$index-1]->[2] == 0 and $coding_segments[$index+1]->[2] == 0; next}
		$alternative_segs++;
		$ade++ if $coding_segments[$index-1]->[2] == 11 and $coding_segments[$index+1]->[2] == 0;
		$aae++ if $coding_segments[$index-1]->[2] == 00 and $coding_segments[$index+1]->[2] == 11;
		$ri++ if $coding_segments[$index-1]->[2] == 11 and $coding_segments[$index+1]->[2] == 11 and $status == 10;
		$si++ if $coding_segments[$index-1]->[2] == 11 and $coding_segments[$index+1]->[2] == 11 and $status == 1;
		$se++ if $coding_segments[$index-1]->[2] == 0 and $coding_segments[$index+1]->[2] == 0 and $status == 1;
		$re++ if $coding_segments[$index-1]->[2] == 0 and $coding_segments[$index+1]->[2] == 0 and $status == 10;
	}
	@return_array = ($ade, $aae, $ri, $si, $se, $re, $ce);
	#@return_array = map{$_/$total_segs} @return_array;
	# return ($alternative_segs, $total_segs, \@coding_segments, @return_array);
	return @return_array;
}

sub calculate_coding_segment
{
	my ($wise_vec, $pasa_vec, $max)= @_;
	
	my @coding_segs;
	my ($seg_start, $seg_end) = (0, 0);
	my $pre_status = 0;
	my $current_status;
	push @coding_segs, [0,0,0];
	#print STDERR "length: ", $max, "\n";
	foreach my $index ( 0..$max+6) # 6 is used to make small blanks for both ends
	{
		#print STDERR 'Index: ', $index, "\n";
		my $w = vec($wise_vec, $index,1);
		$w = 0 unless defined $w;
		my $p =  vec($pasa_vec, $index,1);
		$p = 0 unless defined $p;
		$current_status = $w*10+$p;
		$pre_status = $current_status if $index==0;
		if ($current_status == $pre_status)
		{
			if ($index == ($max+6))
			{
				push @coding_segs, [$seg_start, $max+6, $pre_status]
			}
			next;
		}
		$seg_end = $index - 1;
		push @coding_segs, [$seg_start, $seg_end, $pre_status];
		#print STDERR "Seg: ", $seg_start, "\t", $seg_end, "\t", $pre_status, "\n";
		$seg_start = $index;
		$pre_status = $current_status;		
	}
	push @coding_segs, [0,0,0];
	return (@coding_segs);
}

sub construct_vec
{
	my $arrayref = shift;
	my $length = shift;
	#my $flag= shift;
	my $vec = '';
	my $max;
	my $total;
	my $debug =1 ;
	my @array = @$arrayref;
	#if($flag){shift @array; pop @array} # remove terminal exons SW 10.06.2011
	foreach (@array)
	{
		my @d = sort{$a<=>$b}@$_;
		#print STDERR '@d ', join(",", @d), "\n";
#		print '@d: ', join("\t", @d),"\n" if $debug; $debug=0;
		foreach ($d[0]..$d[1])
		{
			vec($vec,$_,1) = 0b1;
		#	$total++;
			$max = $_ unless defined $max;
			$max = $_ if $_ > $max;
			
		}
	}
	return ($vec, $max);
}
