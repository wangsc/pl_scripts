#!/usr/bin/perl -w
use strict;

my $sUsage = qq(
# This script will read two specifed gff-like file (which is different with normal gff)
# and compare the exon structures in these two files.
# 07.06.2011 SW
perl $0
<gff3 file generated by script run_genewise_wrapper.pl>
<assemblies gff3 file generate by PASA pipeline>
<pasa_chr3A_clean_masked.pasa_assemblies.denovo_transcript_isoforms.gff3>
<exon groups output file>
);
die $sUsage unless @ARGV >= 4;
my($wise_gff, $pasa_gff, $iso_gff, $exon_outfile) = @ARGV;

my %wise_str = read_wise_gff($wise_gff);
my %pasa_str = read_pasa_gff($pasa_gff);
my %iso_gene = read_isoform_gff($iso_gff);
my %gene_iso;
foreach (keys %iso_gene)
{
	push @{ $gene_iso{$iso_gene{$_}} }, $_;
}
my %summary;
my %num_exon_each_gene;
my %acquir_alter_exon;
foreach my $gene (keys %gene_iso)
{
	my $total_exons = 0;
	
	foreach my $iso_id (@{$gene_iso{$gene}})
	{
		my @skipped;
		my $num_exon_pasa;
		foreach my $exon_ref (@{$wise_str{$iso_id}})
		{
			my ($num_exon, @compare_result) = compare_structure($pasa_str{$iso_id}, $exon_ref);
			$total_exons += $num_exon;
			push @{$summary{$gene}}, [@compare_result];
			push @skipped, $compare_result[7];
			$num_exon_pasa = $num_exon unless defined $num_exon_pasa;
		}
		next unless @skipped;
		@skipped = sort{$a<=>$b} @skipped;
		#print 'scalar @skipped ', scalar @skipped,"\n";
		push @{$acquir_alter_exon{$gene}}, [$num_exon_pasa, $skipped[0], $skipped[-1]-$skipped[0]];
	}
	$num_exon_each_gene{$gene} = $total_exons;
}

foreach my $gene (keys %acquir_alter_exon)
{
	my ($t_n, $t_ac, $t_al);
	foreach (@{$acquir_alter_exon{$gene}})
	{
		my ($n, $ac, $al) = @$_;
		$t_n += $n;
		$t_ac += $ac;
		$t_al += $al;
	}
	$acquir_alter_exon{$gene} = [$t_ac/$t_n, $t_al/$t_n];
}


my ($exon_norm_ref, $avg_cov_ref) = normalize(\%summary, \%num_exon_each_gene);
output ($exon_norm_ref, $avg_cov_ref, \%acquir_alter_exon, $exon_outfile);



# Subroutines
sub count_iso_exon
{
	my $hashref = shift;
	my $num_iso;
	my $num_exons;
	foreach (keys %$hashref)
	{
		$num_iso++;
		$num_exons += scalar(@{$hashref->{$_}})
	}
	return($num_iso, $num_exons);
}


sub normalize
{
	my ($summary_ref, $num_exon_ref) = @_;
	my %return;
	my %avg_cov;
	my $total_genes = scalar(keys %{$num_exon_ref});
	my $total_exons;
	map{$total_exons += $_} values %{$num_exon_ref};
	#my $norm_factor = $total_exons/$total_genes;
	my $norm_factor = 1;
	foreach my $gene (keys %{$summary_ref})
	{
		my @exon_array;
		my ($average_cov, $n) = (0,0);
		foreach my $iso (@{$summary_ref->{$gene}})
		{
			foreach my $index (0..9)
			{
				$exon_array[$index] += $iso->[$index];
			}
			$average_cov = ($average_cov*$n+$iso->[11])/($n+1);
			$n++;
		}
		@exon_array = map{($_*$norm_factor)/$num_exon_ref->{$gene}} @exon_array;
		$return{$gene} = [@exon_array];
		$avg_cov{$gene} = $average_cov;
	}
	return (\%return, \%avg_cov);
}


sub read_isoform_gff
{
	my $file = shift;
	my %iso_gene;
	my %iso_contig;
	open (IN, "$file") or die "$! $file\n";
	while (<IN>)
	{
		next if /^\s+$/;
		chomp;
		my ($gene, $iso_id) = $_=~/ID=(.*?)\-(.*?)\;/;
		$iso_gene{$iso_id} = $gene;
		my @data = split /\t/, $_;
		$iso_contig{$gene} = shift @data;
	}
	close IN;
	return %iso_gene;
}


sub output
{
	# $return_hash{$id} = [$left_alt, $right_alt, $conserved, $hc_exon, $retained_intron, $join_exon, $splice_exon, $skip_exon];
	my($exon_ref, $cov_ref, $ac_al_exon, $exon_out) = @_;
	open (E, ">$exon_out") or die "$!\n";
	my @record;
	my @names = qw(left_alt right_alt conserved hc_exon retained_intron join_exon 
								splice_exon skip_exon alternative_acceptor_exon alternative_donor_exon acquired_exon alternative_exon average_coverage);

	print E 'ID',"\t", join("\t", @names),"\n";
	foreach my $gene (keys %{$exon_ref})
	{
		my @array = map{sprintf("%.2f", $_)} @{$exon_ref->{$gene}};
		print E $gene,"\t", join("\t",(@array)),"\t", sprintf("%.2f",$ac_al_exon->{$gene}->[0]),"\t", sprintf("%.2f",$ac_al_exon->{$gene}->[1]),"\t", 
						$cov_ref->{$gene}, "\n";
	}
	close E;
}


sub read_wise_gff
{
	my $file = shift;
	my %return_hash;
	open (IN, $file) or die $!;
	my $score;
	my $genewise_cutoff = 35;
	my @array;
	my $iso_id;
	while (<IN>)
	{
		next if /^\s+$/;
		if (/^\/\//)
		{
			@array = sort{$a->[0] <=> $b->[0]} @array;
			push @{$return_hash{$iso_id}}, [@array];
			@array = ();
			next;
		}
		my @t = split /\t/, $_;
		$iso_id = $t[0];
		if ($t[2] =~ /match/){$score = $t[5]}
		next unless $t[2] =~ /cds/i;
		next unless $score > $genewise_cutoff;
		push @array,[@t[3, 4]];		
	}
	close IN;
	return %return_hash;
}

sub read_pasa_gff
{
	my $file = shift;
	my %return_hash;
	open (IN, $file) or die $!;
	while (<IN>)
	{
		next if /^\s+$/;
		my $id = $1 if /Target=(\S+)\s/;
		my @t = split /\t/, $_;
	#	print $id, "\t", join("\t", @t[3, 4]),"\n" if $id =~ /asmbl_1222/;
		push @{$return_hash{$id}},[@t[3, 4]];		
	}
	close IN;
	map{ $return_hash{$_} = [ sort{$a->[0]<=>$b->[0]} @{$return_hash{$_}} ] }keys %return_hash;
	return %return_hash;
}

sub max
{
	my $m = shift;
	map{$m = $_ if $_>$m} @_;
	return $m;
}

sub min
{
	my $m = shift;
	map{$m = $_ if $_<$m} @_;
	return $m;
}

sub calculate_coverage
{
	my ($wvec, $pvec, $max, $total) = @_;
	my $n = 0;
	foreach (1..$max)
	{
		$n++ if (vec($wvec, $_, 1)==1 and vec($pvec, $_, 1)==1);
	}
	return $n/$total;
}

sub compare_structure
{
	my ($wise_ref, $pasa_ref) = @_;
	my @return_array;
	my $num_exons = 0;
	my $num_compare = 0;
	my ($left_alt, $right_alt, $conserved, $hc_exon, $retained_intron, $join_exon, $splice_exon, $skip_exon) = (0,0,0,0,0,0,0,0);
	my ($alt_acc_exon, $alt_donor_exon) = (0, 0);
	my ($wise_vec, $wise_max, $wise_total) = construct_vec($wise_ref);
	my ($pasa_vec, $pasa_max, $pasa_total) = construct_vec($pasa_ref);
	my $coverage = calculate_coverage($wise_vec, $pasa_vec, $wise_max, $wise_total);
	foreach (@{$wise_ref})
	{
		$num_exons++;
		my ($start, $end) = @$_;
	#	print STDERR '$start, $end ', $start, "\t", $end, "\n" if $id =~ /asmbl_1222/;
		my $covered_by_pasa = 0;
		foreach ($start..$end)
		{
			$covered_by_pasa++ if (vec($pasa_vec, $_,1) == 1);
			#print $_, "\t",  $covered_by_pasa,"\n" if (vec($pasa_vec, $_,1) == 1);
		}
	#	print '$covered_by_pasa ', $covered_by_pasa,"\n" if $id =~ /asmbl_1222/;
		#
		if ($covered_by_pasa >= ($end-$start+1)*0.9 and $covered_by_pasa < ($end-$start+1))
		{
			$hc_exon++ 
		}
		elsif ($covered_by_pasa > 0)
		{
			$retained_intron++ unless $covered_by_pasa == ($end-$start+1);
			$splice_exon++ unless $covered_by_pasa == ($end-$start+1);
		}
		else
		{
			$skip_exon++
		}
		#
		foreach my $p_ref (@{$pasa_ref})
		{
			$num_compare++;
			$conserved++ if $p_ref->[0] == $start and $p_ref->[1] == $end;
			$left_alt ++ if $p_ref->[0] != $start and $p_ref->[1] == $end;
			$right_alt++ if $p_ref->[0] == $start and $p_ref->[1] != $end;
			# alternative_acceptor_exon and alternative_donor_exon
			$alt_acc_exon++ if ($start>$p_ref->[0] and $start<$p_ref->[1] and $end>$p_ref->[1]);
			$alt_donor_exon++ if ($end>$p_ref->[0] and $end<$p_ref->[1] and $start<$p_ref->[0])			
		}
	}
	#
	my @record_indx;
	foreach my $i (0..( (scalar @{$wise_ref})-1 ))
	{
		$record_indx[$i] = [];
		my ($i_start, $i_end) = @{$wise_ref->[$i]};
		foreach my $p (0..(scalar @{$pasa_ref})-1)
		{
			my ($p_start, $p_end) = @{$pasa_ref->[$p]};
			if ($p_end>=$i_end and $p_start<$i_end){push @{$record_indx[$i]},$p;}
			elsif($i_end>=$p_end and $i_start<$p_end){push @{$record_indx[$i]},$p;}
		}
		$join_exon++ if scalar @{$record_indx[$i]} > 1;
	}
		
	foreach (@{$pasa_ref})
	{
		my ($start, $end) = @$_;
#		print STDERR '$start, $end ', $start, "\t", $end, "\n" if $id =~ /asmbl_1222/;
		my $covered_by_wise = 0;
		map{$covered_by_wise++ if (vec($wise_vec, $_,1) == 1)} ($start..$end);
	}
	@return_array = ($left_alt, $right_alt, $conserved, $hc_exon, $retained_intron, $join_exon, 
									 $splice_exon, $skip_exon, $alt_acc_exon, $alt_donor_exon, $num_exons, $coverage);
	 
	return ($num_exons, @return_array);
}



sub construct_vec
{
	my $arrayref = shift;
	my $vec = '';
	my $max;
	my $total;
	my $debug =1 ;
	foreach (@$arrayref)
	{
		my @d = sort{$a<=>$b}@$_;
#		print '@d: ', join("\t", @d),"\n" if $debug; $debug=0;
		foreach ($d[0]..$d[1])
		{
			vec($vec,$_,1) = 0b1;
			$total++;
			$max = $_ unless defined $max;
			$max = $_ if $_ > $max;
			
		}
	}
	return ($vec, $max, $total);
}